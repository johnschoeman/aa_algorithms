c
q
c
finish_pos
c
display start_pos
display next_pos
q
c
display t
c
q
cap - wt
cap - w
cap
display wt_idx
values[wt_idx]
s
n
s
display  t
q
s
n
display t
t[cap][0]
t[cap]
s
display wt
display wt_idx
display cap
s
t
q
n
nn
n
s
wt
s
capacity
values
weights
n
t[capacity][-1]
t[capacity]
t
n
display wt_idx
dipslay wt_idx
n
nn
n
display t
n
t[cap][wt_idx]
display cap
t
s
wt
cap
s
t
q
t
display wt
s
capacity
values
weights
c
q
c
q
n
s
n
s
super_cache[i - j]
s
n
display next_arr
s
display l
display j
display i
display super_cache
display k
k
super_cache
c
display n
n
super_cache
q
super_cache
q
exit
eixt
  end
    prev_base_case
    prev_base_case[k] = next_case + [k]
    end
      end
        next_case << [k - i] + j
      prev_base_case[i].each do |j|
    (1...k).each do |i|
    next_case = []
  def find_next_base_case(prev_base_case, k)
  end
    find_next_base_case(super_frog_base_cases(k-1), k)
    return { 1 => [[1]] } if k == 1
  def super_frog_base_cases(k)
